\documentclass[11pt]{article}
\usepackage{sectsty}
\allsectionsfont{\color{blue}\fontfamily{lmss}\selectfont}
\usepackage{fontspec}
\setmainfont{XCharter}

\usepackage{listings}
\lstset{
basicstyle=\small\ttfamily,
tabsize=8,
columns=flexible,
breaklines=true,
frame=tb,
rulecolor=\color[rgb]{0.8,0.8,0.7},
backgroundcolor=\color[rgb]{1,1,0.91},
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}
\usepackage{fontawesome}


\usepackage{mdframed}
\newmdenv[
  backgroundcolor=gray,
  fontcolor=white,
  nobreak=true,
]{terminalinput}



\usepackage{parskip}


    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)


    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro

    \usepackage{iftex}
    \ifPDFTeX
        \usepackage[T1]{fontenc}
        \IfFileExists{alphabeta.sty}{
              \usepackage{alphabeta}
          }{
              \usepackage[mathletters]{ucs}
              \usepackage[utf8x]{inputenc}
          }
    \else
        \usepackage{fontspec}
        \usepackage{unicode-math}
    \fi

    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage{array}     % table support for pandoc >= 2.11.3
    \usepackage{calc}      % table minipage width calculation for pandoc >= 2.11.1
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}



    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}

    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}


    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{index}





% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.61,0.40,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.80,0.25,0.22}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.46,0.46,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.41,0.47,0.13}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.36,0.12}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.64,0.35,0.47}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.52,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{0.89,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.44,0.44,0.44}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.24,0.48,0.48}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb.
    \makeatletter
        \newbox\Wrappedcontinuationbox
        \newbox\Wrappedvisiblespacebox
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}}
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}}
        \newcommand*\Wrappedcontinuationindent {3ex }
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox}
        % Take advantage of the already applied Pygments mark-up to insert
        % potential linebreaks for TeX processing.
        %        {, <, #, %, $, ' and ": go to next line.
        %        _, }, ^, &, >, - and ~: stay at end of broken line.
        % Use of \textquotesingle for straight quote.
        \newcommand*\Wrappedbreaksatspecials {%
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}%
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}%
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}%
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}%
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}%
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}%
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}%
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}%
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}%
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}%
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}%
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}%
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}%
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}%
        }
        % Some characters . , ; ? ! / are not pygmentized.
        % This macro makes them "active" and they will insert potential linebreaks
        \newcommand*\Wrappedbreaksatpunct {%
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}%
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}%
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}%
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}%
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}%
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}%
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}%
            \catcode`\.\active
            \catcode`\,\active
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active
            \lccode`\~`\~
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%

        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}

    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }



    % Prevent overflowing lines due to hard-to-break entities
    \sloppy
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults

    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}



\renewcommand{\PY}[2]{{#2}}
\usepackage{fancyhdr}
\pagestyle{fancy}
\rhead{\color{gray}\sf\small\rightmark}
\lhead{\nouppercase{\color{gray}\sf\small\leftmark}}
\cfoot{\color{gray}\sf\thepage}
\renewcommand{\footrulewidth}{1pt}
\begin{document}





    \hypertarget{linux-for-bioinformatics}{%
\section{Linux for Bioinformatics}\label{linux-for-bioinformatics}}

\hypertarget{introduction}{%
\subsection{Introduction}\label{introduction}}

Unix and Unix-like operating systems are the standard operating system
on most large computer systems in scientific research, in the same way
that Microsoft Windows is the dominant operating system on desktop PCs.
In this course we will use Linux, a Unix-like operating system which was
originally created to provide a free open source operating system for
PCs.

Linux and MS Windows both perform the important job of managing the
computer's hardware (screen, keyboard, mouse, hard disks, network
connections, etc\ldots) on your behalf. They also provide you with tools
to manage your files and to run application software. They both offer a
graphical user interface (desktop). These desktop interfaces look
different between the operating systems, use different names for things
(e.g.~directory versus folder) and have different images but they mostly
offer the same functionality.

Linux is a powerful, secure, robust and stable operating system which
allows dozens of people to run programs on the same computer at the same
time. This is why it is the preferred operating system for large-scale
scientific computing. It runs on all kinds of machines, from mobile
phones (Android), desktop PCs\ldots{} to supercomputers.

\hypertarget{why-linux}{%
\subsubsection{Why Linux?}\label{why-linux}}

Increasingly, the output of biological research exists as in silico
data, usually in the form of large text files. Linux is particularly
suitable for working with such files and has several powerful and
flexible commands that can be used to process and analyse this data. One
advantage of learning Linux is that many of the commands can be combined
in an almost unlimited fashion. So if you can learn just six Linux
commands, you will be able to do a lot more than just six things.

Linux contains hundreds of commands, but to conduct your analysis you
will probably only need 10 or so to achieve most of what you want to do.
In this tutorial we will introduce you to some basic Linux commands
followed by some more advanced commands and provide examples of how they
can be used in bioinformatics analyses.

\hypertarget{learning-outcomes}{%
\subsection{Learning outcomes}\label{learning-outcomes}}

By the end of the tutorial you can expect to be able to:

\begin{itemize}
\tightlist
\item
  Know what the Linux command line is
\item
  Understand the Linux directory structure and navigate around this
  structure
\item
  Look at and sort the contents of a file
\item
  Use the man command to find out more information about Linux commands
\item
  Extract information from large files
\item
  Use regular expressions to search for particular patterns in a file
\item
  Create a bash script to perform several tasks at once
\end{itemize}

\hypertarget{sections-of-the-linux-tutorial}{%
\subsection{Sections of the Linux
tutorial}\label{sections-of-the-linux-tutorial}}

\textbf{Introduction to Linux} comprises the following sections: 1.
\href{basic.ipynb}{Basic Linux}\\
2. \href{files.ipynb}{Files}\\
3. \href{grep_and_awk.ipynb}{Commands grep and awk}\\
4. \href{advanced_linux.ipynb}{Advanced Linux (loops and Bash scripts}
5. \href{bash.ipynb}{Bash scripting}

\textbf{Note:} We do not expect you to get through all the material in
the time allocated and a good target to aim for is the end of section 3
(\href{grep_and_awk.ipynb}{grep and awk}). The remaining sections are
optional and are for students who would like to expand their Linux
skills and can be completed outside the course hours.

\hypertarget{authors}{%
\subsection{Authors}\label{authors}}

This tutorial was created by
\href{https://github.com/jacquikeane}{Jacqui Keane} and
\href{https://github.com/martinghunt}{Martin Hunt}.

\hypertarget{running-the-commands-in-this-tutorial}{%
\subsection{Running the commands in this
tutorial}\label{running-the-commands-in-this-tutorial}}

    You can follow this tutorial by typing all the commands you see into a
terminal window. This is similar to the ``Command Prompt'' window on MS
Windows systems, which allows the user to type DOS commands to manage
files.

To get started, connect to the \texttt{bioinfsrv} server using the
instructions provided earlier and type the command below:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }\PYZti{}/course\PYZus{}data/linux/data
\end{Verbatim}
\end{tcolorbox}

    Now you can follow the instructions in the tutorial from here.

\hypertarget{cheat-sheet}{%
\subsection{Cheat sheet}\label{cheat-sheet}}

We've also included a \href{cheat_sheet.ipynb}{cheat sheet} at the end
of this tutorial. It probably won't make a lot of sense now, but it
might be a useful reminder of this module later in the tutorial.

\hypertarget{lets-get-started}{%
\subsection{Let's get started!}\label{lets-get-started}}

To get started with the tutorial, go to the next section:
\href{basic.ipynb}{Basic Linux}


    % Add a bibliography block to the postdoc



\newpage





    \hypertarget{basic-linux}{%
\section{Basic Linux}\label{basic-linux}}

\hypertarget{the-commandline}{%
\subsection{The Commandline}\label{the-commandline}}

The commandline or `terminal' is an interface you can use to run
programs and analyse your data. If this is your first time using one it
will seem pretty daunting at first but, with just a few commands, you'll
start to see how it helps you to get things done more efficiently.
You're probably more familiar with software which uses a graphical user
interface, also known as a GUI.

    \hypertarget{getting-started}{%
\subsection{Getting started}\label{getting-started}}

Let's check that you're in the right place. Type the command below in
the terminal window followed by the \texttt{Enter} key:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{pwd}
\end{Verbatim}
\end{tcolorbox}

    It should display something similar to:

    \texttt{/home/username/course\_data/linux/data}

    Instead of the text \texttt{username} above you should see your
username, for example:

    \texttt{/home/jacqui/course\_data/linux/data}

    Then continue through the course, entering any commands that you
encounter (highlighted in a grey box with a keyboard symbol) into your
terminal window. Let's start by moving into the directory called
\texttt{basic}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }basic
\end{Verbatim}
\end{tcolorbox}

    Before getting started there are some general points to remember that
will make your life easier:

\begin{itemize}
\tightlist
\item
  Linux is case sensitive - typing \texttt{ls} is not the same as typing
  \texttt{LS}.
\item
  Often when you have problems with Linux, it is due to a spelling
  mistake. Check that you have not missed or added a space. Pay careful
  attention when typing commands across a couple of lines.
\end{itemize}

    \hypertarget{files-and-directories}{%
\subsection{Files and directories}\label{files-and-directories}}

\textit{Directories} are the Linux equivalent of folders on a PC or Mac.
They are organised in a hierarchy, so directories can have
sub-directories and so on. Directories are very useful for organising
your work and keeping your account tidy - for example, if you have more
than one project, you can organise the files for each project into
different directories to keep them separate. You can think of
directories as rooms in a house. You can only be in one room (directory)
at a time. When you are in a room you can see everything in that room
easily. To see things in other rooms, you have to go to the appropriate
door and crane your head around. Linux works in a similar manner, moving
from directory to directory to access files. The location or directory
that you are in is referred to as the current working directory.

For the file called \texttt{index.ipynb} under the \texttt{linux}
directory, the location or full pathname can be expressed as:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }/home/manager/course\PYZus{}data/linux/practical/Notebooks/index.ipynb
\end{Verbatim}
\end{tcolorbox}

    \begin{figure}
\centering
\includegraphics{images/directory_structure.png}
\caption{Directory structure}
\end{figure}

    \hypertarget{pwd---find-where-you-are}{%
\subsection{pwd - find where you are}\label{pwd---find-where-you-are}}

The command \texttt{pwd} stands for print working directory. A
\textit{command} (also known as a \textit{program}) is something which tells
the computer to do something. Commands are therefore often the first
thing that you type into the terminal.

As described above, directories (folders) are arranged in a hierarchical
structure. To determine where you are in the hierarchy you can use the
\texttt{pwd} command to display the name of the current working
directory. The current working directory may be thought of as the
directory you are in, i.e.~your current position in the file-system
tree.

To find out where you are, type the following:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{pwd}
\end{Verbatim}
\end{tcolorbox}

    Remember that Linux is case sensitive, \texttt{PWD} is not the same as
\texttt{pwd}.

\texttt{pwd} will list each of the directories you would need to
navigate through to get from the \texttt{root} (top level directory) of
the file system to your current directory. This is sometimes refered to
as your `absolute path' to distinguish that it gives a complete route
rather than a `relative path' which tells you how to get from the
current working directory to another directory. More on that shortly.

    \hypertarget{ls---list-the-contents-of-a-directory}{%
\subsection{ls - list the contents of a
directory}\label{ls---list-the-contents-of-a-directory}}

The command \texttt{ls} stands for list. The \texttt{ls} command can be
used to list the contents of a directory.

To list the contents of your current working directory type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls
\end{Verbatim}
\end{tcolorbox}

    You should see that there are 4 items in this directory.

To list the contents of a directory with extra information about the
items type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }\PYZhy{}l
\end{Verbatim}
\end{tcolorbox}

    Instead of printing out a simple list, this should have printed out
additional information about each file. Note that there is a space
between the command \texttt{ls} and the \texttt{-l}. There is no space
between the dash and the letter l.

\texttt{-l} is our first example of an \textit{option}. Many commands have
options which change their behaviour but are not always required.

What do each of the columns represent? (file permissions, file owner,
group owner, size, date)

    To list all contents of a directory including hidden files and
directories (hidden files and directories are not shown by default and
are used to help important data from being deleted) type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }\PYZhy{}a\PY{+w}{ }\PYZhy{}l
\end{Verbatim}
\end{tcolorbox}

    This is an example of a command which can take multiple options at the
same time.

How many hidden files and directories are there?

    Try the same command but with the \texttt{-h} option:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }\PYZhy{}alh
\end{Verbatim}
\end{tcolorbox}

    You'll also notice that we've combined \texttt{-a\ -l\ -h} into what
appears to be a single \texttt{-alh} option. It's almost always ok to do
this for options which are made up of a single dash followed by a single
letter.

What does the \texttt{-h} option do?

    To list the contents of the directory called Pfalciparum with extra
information type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }\PYZhy{}l\PY{+w}{ }Pfalciparum/
\end{Verbatim}
\end{tcolorbox}

    Here we gave the command \texttt{ls} the \textit{option} \texttt{-l} and
the \textit{argument} \texttt{Pfalciparum}. Arguments are very similar to
options, they are used to provide additional information to a command
and often refer to things which are not prefixed with dashes.

In this example we have provided information about the directory that we
want to list the contents of, this argument \texttt{Pfalciparum} is the
\textit{relative path} to the directory \texttt{Pfalciparum} from our
current working directory.

How many files are there in this directory?

    \hypertarget{tab-completion}{%
\subsection{Tab completion}\label{tab-completion}}

Typing out directory or file names is really boring and you're likely to
make typos which will at best make your command fail with a strange
error and at worst overwrite some of your carefully crafted analysis.
\textit{Tab completion} is a trick which normally reduces this risk
significantly.

Instead of typing out \texttt{ls\ Pfalciparum/}, try typing
\texttt{ls\ P} and then press the \texttt{tab} key (instead of
\texttt{Enter}). The rest of the folder name should just appear. If you
have two files of directories with simiar names
(e.g.~\texttt{directory\_structure.png} and
\texttt{directory\_structure2.png}) then you might need to give your
terminal a bit of a hand to work out which one you want. In this case
you would type \texttt{ls\ -l\ d}, when you press \texttt{tab} the
terminal would read \texttt{ls\ -l\ directory\_structure}, you could
then type \texttt{2} followed by another \texttt{tab} and it would work
out that you meant \texttt{directory\_structure2.png}

    \hypertarget{file-permissions}{%
\subsection{File permissions}\label{file-permissions}}

Every file and directory has a set of permissions which restrict what
can be done with a file or directory.

\begin{itemize}
\tightlist
\item
  Read (r): permission to read from a file/directory
\item
  Write (w): permission to modify a file/directory
\item
  Execute (x): Tells the operating system that the file contains code
  for the computer to run, as opposed to a file of text which you open
  in a text editor.
\end{itemize}

In the terminal window type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }\PYZhy{}l
\end{Verbatim}
\end{tcolorbox}

    This shows the permissions associate with each file and directory. The
first set of permissions (characters 2,3,4) refer to what the owner of
the file can do, the second set of permissions (5,6,7) refers to what
members of the Linux group can do and the third set of permissions
(8,9,10) refers to what everyone else can do.

    \hypertarget{cd---change-current-working-directory}{%
\subsection{cd - change current working
directory}\label{cd---change-current-working-directory}}

The command \texttt{cd} stands for change directory.

The \texttt{cd} command will move you from the current working directory
to another directory, in other words allow you to move up or down in the
directory hierarchy.

To move into the \texttt{Styphi} directory type the following. Note,
you'll remember this more easily if you type this rather than copying
and pasting. Also remember that you can use tab completion to save
typing all of it.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }Styphi/
\end{Verbatim}
\end{tcolorbox}

    Now use the \texttt{pwd} command to check your location in the directory
hierarchy and the \texttt{ls} command to list the contents of this
directory.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{pwd}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls
\end{Verbatim}
\end{tcolorbox}

    You should see that there are 3 files called: \texttt{Styphi.fa},
\texttt{Stypi.gff}, \texttt{Styphi.noseq.gff}

    \hypertarget{tips}{%
\subsection{Tips}\label{tips}}

There are some short cuts for referring to directories:

\begin{itemize}
\tightlist
\item
  . Current directory (one full stop)
\item
  .. Directory above in the hierarchy (two full stops)
\item
  \textasciitilde{} Home directory (tilde)
\item
  / Root of the file system (like C:~in Windows)
\end{itemize}

Try the following commands, what do they do?

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }.
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }..
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }\PYZti{}
\end{Verbatim}
\end{tcolorbox}

    As you may remember, \texttt{ls} will only \textit{list} what is in the
directories. To move to the directory, you need to use \texttt{cd}. Try
moving between directories a few times. Can you get into the
\texttt{Pfalciparum/} and then back into \texttt{Styphi/}? It might be
useful to look at Figure 1 when attempting this task.

    When you are finished moving between directories, moved to the Styphi
directory and type the command below.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{pwd}
\end{Verbatim}
\end{tcolorbox}

    It should return a similar result below (but instead of username it will
have your actual username). If th results is not as below then you are
not in the \texttt{Styphi} directory.

    \texttt{/home/username/course\_data/linux/data/basic/Styphi}

    If you are not in the \texttt{Styphi} directory then use the command
below (remember to replace username with your actual username
e.g.~jacqui) to move to the \texttt{Styphi} directory:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }/home/username/course\PYZus{}data/linux/data/basic/Styphi
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{cp---copy-a-file}{%
\subsection{cp - copy a file}\label{cp---copy-a-file}}

The command \texttt{cp} stands for copy.

The \texttt{cp} command will copy a file from one location to another
and you will end up with two copies of the file.

    To copy the file \texttt{Styphi.gff} to a new file called
\texttt{StyphiCT18.gff} type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cp\PY{+w}{ }Styphi.gff\PY{+w}{ }StyphiCT18.gff
\end{Verbatim}
\end{tcolorbox}

    Use \texttt{ls} to check the contents of the current directory for the
copied file:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{mv---move-a-file}{%
\subsection{mv - move a file}\label{mv---move-a-file}}

The \texttt{mv} command stand for move.

The \texttt{mv} command will move a file from one location to another.
This moves the file rather than copies it, therefore you end up with
only one file rather than two. When using the command, the path or
pathname is used to tell Linux where to find the file. You refer to
files in other directories by using the list of hierarchical names
separated by slashes. For example, the file called
\texttt{StyphiCT18.gff} in the directory \texttt{Styphi} has the path
\texttt{Styphi/StyphiCT18}. If no path is specified, Linux assumes that
the file is in the current working directory.

To move the file \texttt{StyphiCT18.gff} from the \texttt{Styphi}
directory to the current directory type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }..
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
mv\PY{+w}{ }Styphi/StyphiCT18.gff\PY{+w}{ }.
\end{Verbatim}
\end{tcolorbox}

    Use the \texttt{ls} command to check the contents of the \texttt{Styphi}
directory and the current directory to see that \texttt{StyphiCT18.gff}
has been moved.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }Styphi
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{rm---delete-a-file}{%
\subsection{rm - delete a file}\label{rm---delete-a-file}}

The command \texttt{rm} stands for remove.

The \texttt{rm} command will delete a file permanently from your
computer so take care!

To remove the copy of the S. typhi file, called \texttt{StyphiCT18.gff}
type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
rm\PY{+w}{ }StyphiCT18.gff
\end{Verbatim}
\end{tcolorbox}

    Use the \texttt{ls} command to check the contents of the current
directory to see that the file \texttt{StyphiCT18.gff} has been removed.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls
\end{Verbatim}
\end{tcolorbox}

    Unfortunately there is no ``recycle bin'' on the command line to recover
the file from, so you have to be careful!

    \hypertarget{find---find-a-file}{%
\subsection{find - find a file}\label{find---find-a-file}}

The \texttt{find} command can be used to find files matching a given
pattern. It can be used to recursively search the directory tree for a
specified name, seeking files and directories that match the given name.

    To find all files in the current directory and all its subdirectories
that end with the suffix gff:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
find\PY{+w}{ }.\PY{+w}{ }\PYZhy{}name\PY{+w}{ }*.gff
\end{Verbatim}
\end{tcolorbox}

    How many gff files did you find?

    To find all the subdirectories contained in the current directory type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
find\PY{+w}{ }.\PY{+w}{ }\PYZhy{}type\PY{+w}{ }d
\end{Verbatim}
\end{tcolorbox}

    How many subdirectories did you find?

    \hypertarget{exercises}{%
\subsection{Exercises}\label{exercises}}

Many people panic when they are confronted with a Linux prompt! Don't!
All the commands you need to solve these exercises are provided above
and don't be afraid to make a mistake. If you get lost ask an
instructor. If you are a person skilled at Linux, be patient this is
only a short exercise.

To begin, open a terminal window and navigate to the \texttt{basic}
directory under the the \texttt{linux} directory (remember use the
command \texttt{cd}) and then complete the exercise below.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Use the \texttt{ls} command to show the contents of the \texttt{basic}
  directory.
\item
  How many files are there in the \texttt{Pfalciparum} directory?
\item
  What is the largest file in the \texttt{Pfalciparum} directory?
\item
  Move into the \texttt{Pfalciparum} directory.
\item
  How many files are there in the \texttt{fasta} directory?
\item
  Copy the file \texttt{Pfalciparum.bed} in the \texttt{Pfalciparum}
  directory into the \texttt{annotation} directory.
\item
  Move all the fasta files in the directory \texttt{Pfalciparum} to the
  \texttt{fasta} directory.
\item
  How many files are there in the \texttt{fasta} directory?
\item
  Use the \texttt{find} command to find all gff files in the
  \texttt{linux} directory, how many files did you find?
\item
  Use the \texttt{find} command to find all the fasta files in the
  \texttt{linux} directory, how many files did you find?
\end{enumerate}

    When you have completed these exercises move on to the next part of the
tutorial, \href{files.ipynb}{looking inside files}.


    % Add a bibliography block to the postdoc



\newpage





    \hypertarget{looking-inside-files}{%
\section{Looking inside files}\label{looking-inside-files}}

A common task is to look at the contents of a file. This can be achieved
using several different Linux commands, \texttt{less}, \texttt{head} and
\texttt{tail}. Let us consider some examples.

But first, change directory to the \texttt{files} directory. You may
find Figure 1 useful here as depending on the directory you are
currently in you may need to use a different \texttt{cd} command than
the one shown below.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{pwd}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }../../files
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{less}{%
\subsection{less}\label{less}}

The \texttt{less} command displays the contents of a specified file one
screen at a time. To test this command type the following command
followed by the enter key:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
less\PY{+w}{ }Styphi.gff
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
head\PY{+w}{ }Styphi.gff
\end{Verbatim}
\end{tcolorbox}

    The contents of the file \texttt{Styphi.gff} is displayed one screen at
a time, to view the next screen press the space bar. As
\texttt{Styphi.gff} is a large file this will take a while, therefore
you may want to escape or exit from this command. To do this, press the
q key, this kills the \texttt{less} command and returns you to the
command prompt. The \texttt{less} command can also scroll backwards if
you hit the \texttt{b} key. Another useful feature is the slash key,
\texttt{/}, to search for an expression in the file. Try it, search for
the gene with locus tag t0038. What is the start and end position of
this gene?

    \hypertarget{head-and-tail}{%
\subsection{head and tail}\label{head-and-tail}}

Sometimes you may just want to view the text at the beginning or the end
of a file, without having to display all of the file. The \texttt{head}
and \texttt{tail} commands can be used to do this.

    The \texttt{head} command displays the first ten lines of a file.

To look at the beginning of the fie \texttt{Styphi.gff} file type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
head\PY{+w}{ }Styphi.gff
\end{Verbatim}
\end{tcolorbox}

    The \texttt{tail} command displays the last ten lines of a file.

To look at the end of \texttt{Styphi.gff} type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
tail\PY{+w}{ }Styphi.gff
\end{Verbatim}
\end{tcolorbox}

    The amount of the file that is displayed can be increased by adding
extra options. To increase the number of lines viewed from 10 to 25 add
\texttt{-n\ 25} to the command:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
tail\PY{+w}{ }\PYZhy{}n\PY{+w}{ }\PY{l+m}{25}\PY{+w}{ }Styphi.gff
\end{Verbatim}
\end{tcolorbox}

    In this case you've given tail an option in two parts. In this case the
\texttt{-n} says that you want to specify the number of lines to show
and the \texttt{25} bit tells it how many. Unlike earlier when we merged
options like \texttt{ls\ -lha} together, it's not a good idea to merge
multiple two part options together because otherwise it is ambiguous
which value goes with which option.

The \texttt{-n} option is such a common option for \texttt{tail} and
\texttt{head} that it even has a shorthand: \texttt{-n\ 25} and
\texttt{-25} mean the same thing.

    \hypertarget{saving-time}{%
\subsection{Saving time}\label{saving-time}}

Saving time while typing may not seem important, but the longer that you
spend in front of a computer, the happier you will be if you can reduce
the time you spend at the keyboard.

\begin{itemize}
\item
  Pressing the up/down arrows will let you scroll through previous
  commands entered.
\item
  If you highlight some text, middle clicking on the mouse will paste it
  on the command line.
\item
  Tab completion doesn't just work on directory and file names, it also
  works on commands. Try it by typing \texttt{tai} and pressing yhe
  \texttt{tab} key.
\end{itemize}

Although tab completion works on commands and filenames, unfortunately
it does not work on options or other arguments.

    \hypertarget{getting-help-man}{%
\subsection{Getting help man}\label{getting-help-man}}

To obtain further information on any of the Linux commands introduced in
this course you can use the \texttt{man} command. For example, to get a
full description and examples of how to use the \texttt{tail} command
type the following command in a terminal window.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
man\PY{+w}{ }tail
\end{Verbatim}
\end{tcolorbox}

    There are several other useful commands that can be used to manipulate
and summarise information inside files and we will introduce some of
these next, \texttt{cat}, \texttt{sort}, \texttt{wc} and \texttt{uniq}.

    \hypertarget{writing-to-files}{%
\subsection{Writing to files}\label{writing-to-files}}

So far we've been running commands and outputting the results into the
terminal. That's obviously useful but what if you want to save the
results to another file?

Type this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
head\PY{+w}{ }\PYZhy{}1\PY{+w}{ }Styphi.gff\PY{+w}{ }\PYZgt{}\PY{+w}{ }first\PYZus{}Styphi\PYZus{}line.txt
\end{Verbatim}
\end{tcolorbox}

    It may look like nothing has happened. This is because the
\texttt{\textgreater{}} character has \textit{redirected} the output of
the \texttt{head} command. Instead of writing to the \textit{standard
output} (in this case your terminal) it sent the output into the file
\texttt{first\_Styphi\_line.txt}. Note that tab completion works for
\texttt{Styphi.gff} because it exists but doesn't work for
\texttt{first\_Styphi\_line.txt} because it doesn't exist yet.

    \hypertarget{cat}{%
\subsection{cat}\label{cat}}

\texttt{cat} is another way of reading files, but unlike \texttt{less}
it just throws the entire contents of the file to your standard output.
Try it on \texttt{first\_Styphi\_line.txt}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }first\PYZus{}Styphi\PYZus{}line.txt
\end{Verbatim}
\end{tcolorbox}

    We don't need \texttt{first\_Styphi\_line.txt} any more so delete it by
typing

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
rm\PY{+w}{ }first\PYZus{}Styphi\PYZus{}line.txt
\end{Verbatim}
\end{tcolorbox}

    The \texttt{cat} command can also be given the names of multiple files,
one after the other and it will just output the contents of all files.
The order in which the files are displayed is determined by the order in
which they appear in the command line. You can use this concept and the
\texttt{\textgreater{}} symbol to join files together into a single
file.

Having looked at the beginning and end of the \texttt{Styphi.gff} file
you should notice that in the GFF file the annotation comes first, then
the DNA sequence at the end. If you had two separate files containing
the annotation and the DNA sequence, it is possible to concatenate or
join the two together to make a single file like the \texttt{Styphi.gff}
file you have just looked at.

For example, we have two separate files, \texttt{Styphi.noseq.gff} and
\texttt{Styphi.fa}, that contain the annotation and DNA sequence,
respectively for the Salmonella typhi CT18 genome. To join together
these files type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }Styphi.noseq.gff\PY{+w}{ }Styphi.fa\PY{+w}{ }\PYZgt{}\PY{+w}{ }Styphi.concatenated.gff
\end{Verbatim}
\end{tcolorbox}

    The files \texttt{Styphi.noseq.gff} and \texttt{Styphi.fa} will be
joined together and written to a new file called
\texttt{Styphi.concatenated.gff}.

The \texttt{\textgreater{}} symbol in the command line directs the
output of the cat program to the designated file
\texttt{Styphi.concatenated.gff}. Use the command \texttt{ls} to check
for the presence of this file.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{wc---counting}{%
\subsection{wc - counting}\label{wc---counting}}

The command \texttt{wc} counts lines, words or characters.

There are two ways you could use it:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
wc\PY{+w}{ }\PYZhy{}l\PY{+w}{ }Styphi.gff
\end{Verbatim}
\end{tcolorbox}

    or

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }Styphi.gff\PY{+w}{ }\PY{p}{|}\PY{+w}{ }wc\PY{+w}{ }\PYZhy{}l
\end{Verbatim}
\end{tcolorbox}

    Both give a similar answer. In the first example you tell \texttt{wc}
the file that you want it to review (\texttt{Styphi.gff}) and pass the
\texttt{-l} option to say that you're only interested in the number of
lines.

In the second example you use the \texttt{\textbar{}} symbol which is
also known as the \textit{pipe} symbol. This \textit{pipes} (sends) the
output of \texttt{cat\ Styphi.gff} into the input of \texttt{wc\ -l}.
This means that you can also use the same \texttt{wc} tool to count
other things. For example to count the number of files that are listed
by \texttt{ls} type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }\PY{p}{|}\PY{+w}{ }wc\PY{+w}{ }\PYZhy{}l
\end{Verbatim}
\end{tcolorbox}

    You can connect as many commands as you want. For example, type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }\PY{p}{|}\PY{+w}{ }grep\PY{+w}{ }\PY{l+s+s2}{\PYZdq{}.gff\PYZdq{}}\PY{+w}{ }\PY{p}{|}\PY{+w}{ }wc\PY{+w}{ }\PYZhy{}l
\end{Verbatim}
\end{tcolorbox}

    What does this command do? You will learn more about the \texttt{grep}
command later in this course.

    \hypertarget{sort---sorting-values}{%
\subsection{sort - sorting values}\label{sort---sorting-values}}

The \texttt{sort} lets you sort the contents of the input. When you sort
the input, lines with identical content end up next to each other in the
output. This is useful as the output can then be fed to the
\texttt{uniq} command (see below) to count the number of unique lines in
the input.

We will use a small example file (in ``BED'' format), which contains
information about gene features in Plasmodium falciparum. A bed file is
a column-based file, with a tab character between each column. There can
be more than 10 columns, but only the first three are required to be a
valid file. The file format is described in full here:
\url{http://genome.ucsc.edu/FAQ/FAQformat\#format1}. We will use the
first 5 columns:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  sequence name of where the feature is found
\item
  start position (starting from 0, not 1)
\item
  end position (starting from 0, not 1)
\item
  feature name
\item
  score
\end{enumerate}

Look at the contents of the BED file:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
head\PY{+w}{ }Pfalciparum.bed
\end{Verbatim}
\end{tcolorbox}

    To sort the contents of a BED file type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
sort\PY{+w}{ }Pfalciparum.bed
\end{Verbatim}
\end{tcolorbox}

    Now type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
sort\PY{+w}{ }Pfalciparum.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }head
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
sort\PY{+w}{ }Pfalciparum.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }tail
\end{Verbatim}
\end{tcolorbox}

    To sort the contents of a BED file on position, type the following
command.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
sort\PY{+w}{ }\PYZhy{}k\PY{+w}{ }\PY{l+m}{2}\PY{+w}{ }\PYZhy{}n\PY{+w}{ }Pfalciparum.bed
\end{Verbatim}
\end{tcolorbox}

    The \texttt{sort} command can sort by multiple columns e.g.~1st column
and then 2nd column by specifying successive \texttt{-k} options in the
command. Type the following commands:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
sort\PY{+w}{ }\PYZhy{}k\PY{+w}{ }\PY{l+m}{2}\PY{+w}{ }\PYZhy{}n\PY{+w}{ }Pfalciparum.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }head
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
sort\PY{+w}{ }\PYZhy{}k\PY{+w}{ }\PY{l+m}{2}\PY{+w}{ }\PYZhy{}n\PY{+w}{ }Pfalciparum.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }tail
\end{Verbatim}
\end{tcolorbox}

    Why not have a look at the manual for \texttt{sort} to see what these
\texttt{-k} and \texttt{-n} options do? Remember that you can type
\texttt{/} followed by a search phrase, \texttt{n} to find the next
search hit, \texttt{N} to find the previous search hit and \texttt{q} to
exit.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
man\PY{+w}{ }sort
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{uniq---finding-unique-values}{%
\subsection{uniq - finding unique
values}\label{uniq---finding-unique-values}}

The \texttt{uniq} command extracts unique lines from the input. It is
usually used in combination with \texttt{sort} to count unique values in
the input.

    To get the list of chromosomes in the Pfalciparum bed file type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
awk\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZob{} print \PYZdl{}1 \PYZcb{}\PYZsq{}}\PY{+w}{ }Pfalciparum.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }sort\PY{+w}{ }\PY{p}{|}\PY{+w}{ }uniq
\end{Verbatim}
\end{tcolorbox}

    How many chromosomes are there? You will learn more about the
\texttt{awk} command later in this course.

Warning: \texttt{uniq} is really stupid; it can only spot that two lines
are the same if they are right next to one another. You therefore almost
always want to \texttt{sort} your input data before using \texttt{uniq}.

Do you understand how this command is working? Why not try building it
up piece by piece to see what it does?

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
awk\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZob{} print \PYZdl{}1 \PYZcb{}\PYZsq{}}\PY{+w}{ }Pfalciparum.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }less
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
awk\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZob{} print \PYZdl{}1 \PYZcb{}\PYZsq{}}\PY{+w}{ }Pfalciparum.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }sort\PY{+w}{ }\PY{p}{|}\PY{+w}{ }less
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
awk\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZob{} print \PYZdl{}1 \PYZcb{}\PYZsq{}}\PY{+w}{ }Pfalciparum.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }sort\PY{+w}{ }\PY{p}{|}\PY{+w}{ }uniq\PY{+w}{ }\PY{p}{|}\PY{+w}{ }less
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{exercises}{%
\subsection{Exercises}\label{exercises}}

Open up a new terminal window, navigate to the \texttt{files} directory
under the \texttt{linux/data} directory and complete the following
exercises:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Use the \texttt{head} command to extract the first 500 lines of the
  file \texttt{Styphi.gff} and store the output in a new file called
  \texttt{Styphi.500.gff}.
\item
  Use the \texttt{tail} command to extract the last 100 lines of the
  file \texttt{Styphi.gff} and store the output in a new file called
  \texttt{Styphi.end.gff}.
\item
  Use the \texttt{wc} command to count the number of lines in the
  \texttt{Pfalciparum.bed} file.
\item
  Use the \texttt{sort} command to sort the file
  \texttt{Pfalciparum.bed} on chromosome and then gene position.
\item
  Use the \texttt{uniq} command to count the number of features per
  chromosome in the \texttt{Pfalciparum.bed} file. Hint: use the man
  command to look at the options for the uniq command. Or peruse the
  \texttt{wc} or \texttt{grep} manuals.
\end{enumerate}

    When you have completed these exercises move on to the next part of the
tutorial, \href{grep_and_awk.ipynb}{grep and awk}.


    % Add a bibliography block to the postdoc



\newpage





    \hypertarget{the-commands-grep-and-awk}{%
\section{\texorpdfstring{The commands \texttt{grep} and
\texttt{awk}}{The commands grep and awk}}\label{the-commands-grep-and-awk}}

In this section we will introduce the commands \texttt{grep} and
\texttt{awk}.

    \hypertarget{searching-inside-files-with-grep}{%
\subsection{\texorpdfstring{Searching inside files with
\texttt{grep}}{Searching inside files with grep}}\label{searching-inside-files-with-grep}}

A common task is to extract information from large files. This can be
achieved using the Linux command \texttt{grep}, which stands for
``Globally search for a Regular Expression and Print''. The meaning of
this acronym will become clear later, when we discuss Regular
Expressions. First, we will consider simpler examples.

Before we start, change into the \texttt{grep} directory:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }../grep
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{simple-pattern-matching}{%
\subsubsection{Simple pattern matching}\label{simple-pattern-matching}}

We will use a small example file (in ``BED'' format), which contains the
expression levels of some genes. Remember, this is a column-based file,
with a tab character between each column. There can be more than 10
columns, but only the first three are required to be a valid file. The
file format is described in full here:
\url{http://genome.ucsc.edu/FAQ/FAQformat\#format1}. We will use the
first 5 columns:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Sequence name
\item
  start position (starting from 0, not 1)
\item
  end position (starting from 0, not 1)
\item
  feature name
\item
  score (which is used to store the gene expression level in our
  examples).
\end{enumerate}

Here is the contents of the first example BED file used in this section:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }gene\PYZus{}expression.bed
\end{Verbatim}
\end{tcolorbox}

    In reality, such a file could contain 100,000s of lines, so that it is
not practical to read manually. Suppose we are interested in all the
genes from chromosome 2. We can find all these lines using grep:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }chr2\PY{+w}{ }gene\PYZus{}expression.bed
\end{Verbatim}
\end{tcolorbox}

    This has shown us all the lines that contain the text or string
``chr2''.

We can use a pipe to then just extract the genes that are on the
positive strand, using grep a second time:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }chr2\PY{+w}{ }gene\PYZus{}expression.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }grep\PY{+w}{ }+
\end{Verbatim}
\end{tcolorbox}

    However, since \texttt{grep} is reporting a match to a string
\textit{anywhere} on a line, such simple searches can have undesired
consequences. For example, consider the result of doing a similar search
for all the genes in chromosome 1:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }chr1\PY{+w}{ }gene\PYZus{}expression.bed
\end{Verbatim}
\end{tcolorbox}

    Oops! We found genes in chromosome 10, because ``chr1'' is a substring
(subset) of ``chr10''.

Or consider the following file, where the genes have unpredictable names
(which is not unusual for bioinformatics data).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }gene\PYZus{}expression\PYZus{}sneaky.bed
\end{Verbatim}
\end{tcolorbox}

    Now we try to find genes on chromosome 1 that are on the negative
strand. We put the minus sign in quotes, to stop Linux interpreting this
as an option to \texttt{grep}, as opposed to the string we are searching
for:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }chr1\PY{+w}{ }gene\PYZus{}expression\PYZus{}sneaky.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }grep\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZhy{}\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

    The extra lines are found by \texttt{grep} because of matches in columns
we were not expecting to match. Remember, \texttt{grep} is reporting
these lines because they each contain the strings ``chr1'' and ``-''
\textit{somewhere}.

We need a way to make searching with \texttt{grep} more specific.

\hypertarget{regular-expressions}{%
\subsubsection{Regular expressions}\label{regular-expressions}}

Regular expressions provide the solution to the above problems. They are
ways of defining more specific patterns to search for.

\hypertarget{matching-the-start-and-end-of-lines}{%
\paragraph{Matching the start and end of
lines}\label{matching-the-start-and-end-of-lines}}

First, we can specify that a match must be at the start of a line using
the symbol ``\texttt{\^{}}'', which means ``start of line''. Without the
\texttt{\^{}}, we find any match to ``chr1'':

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }chr1\PY{+w}{ }gene\PYZus{}expression\PYZus{}sneaky.bed
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZca{}chr1\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression\PYZus{}sneaky.bed
\end{Verbatim}
\end{tcolorbox}

    Good! We have removed the match to the badly-named gene ``chr11.gene1'',
which is on chromosome 8. Now we want to avoid matching chromosomes 10
and 11. This can be done by also looking for a ``tab'' character, which
is represented by writing \texttt{\textbackslash{}t}. For technical
reasons, which are beyond the scope of this course, we must also put a
dollar sign before the quotes to make any search involving a tab
character work.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PY{l+s+s1}{\PYZdl{}\PYZsq{}\PYZca{}chr1\PYZbs{}t\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression\PYZus{}sneaky.bed
\end{Verbatim}
\end{tcolorbox}

    To find the genes on the negative strand, all that remains is to match a
minus sign at the \textit{end} of the line (so that we do not find
``sneaky-gene3''). We can do this using the dollar ``\texttt{\$}'',
which means ``end of line''.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PY{l+s+s1}{\PYZdl{}\PYZsq{}\PYZca{}chr1\PYZbs{}t\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression\PYZus{}sneaky.bed\PY{+w}{ }\PY{p}{|}\PY{+w}{ }grep\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZbs{}\PYZhy{}\PYZdl{}\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{wildcards-and-alphabets}{%
\paragraph{Wildcards and alphabets}\label{wildcards-and-alphabets}}

Another special character in regular expressions is the dot: ``.''. This
stands for any single character. For example, this finds all matches to
chromosomes 1-9, and chromosomes X and Y:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PY{l+s+s1}{\PYZdl{}\PYZsq{}\PYZca{}chr.\PYZbs{}t\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression.bed
\end{Verbatim}
\end{tcolorbox}

    In fact, the earlier command that found all genes on chromosome 1 that
are on the negative strand, could be found with a single call to
\texttt{grep} instead of two calls piped together. To do this, we need a
regular expression that finds lines that:

\begin{itemize}
\tightlist
\item
  start with chr1, then a tab character
\item
  end with a minus
\item
  have arbitrary characters between.
\end{itemize}

The asterisk ``*'' has a special meaning: it says to match any number
(including zero) of whatever character is before the *. For example, the
regular expression `AC*G' will match AG, ACG, ACCG, etc. The simpler,
improved command is:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PY{l+s+s1}{\PYZdl{}\PYZsq{}\PYZca{}chr1\PYZbs{}t.*\PYZhy{}\PYZdl{}\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression\PYZus{}sneaky.bed
\end{Verbatim}
\end{tcolorbox}

    As well as matching any character using a dot, we can define any list of
characters to match, using square brackets. For example, {[}12X{]} means
match a 1, 2, or an X. This can be used to find all genes from
chromosomes 1, 2 and X:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PY{l+s+s1}{\PYZdl{}\PYZsq{}\PYZca{}chr[12X]\PYZbs{}t\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression.bed
\end{Verbatim}
\end{tcolorbox}

    Or just the autosomes may be of interest. To do this we introduce two
new features:

\begin{itemize}
\tightlist
\item
  Ranges can be given in square brackets, for example {[}1-5{]} will
  match 1, 2, 3, 4 or 5.
\item
  The plus sign ``+'' has a special meaning that is similar to ``*''.
  Instead of any number of matches (including zero), it looks for at
  least one match. To avoid simply matching a plus sign, it must be
  preceded by a backslash: ``\textbackslash+''. For example, the regular
  expression `AC\textbackslash+G' will match ACG, ACCG, ACCCG etc (but
  will not match AG).
\end{itemize}

Warning: Adding a backslash is often called \textit{escaping}
(e.g.~\textit{escape the plus symbol}). Depending on the software you're
using (and the options you give it), you may need to escape the symbol
to indicate that you want its special regex meaning (e.g.~multiple
copies of the last character please) or its literal meaning (e.g.~give
me a `+' symbol please). If your command isn't working as you expect,
try playing with these options and always test your regular expression
before assuming it gave you the right answer.

The command to find the autosomes is:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PY{l+s+s1}{\PYZdl{}\PYZsq{}\PYZca{}chr[0\PYZhy{}9]\PYZbs{}+\PYZbs{}t\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression.bed
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{other-grep-options}{%
\subsubsection{\texorpdfstring{Other \texttt{grep}
options}{Other grep options}}\label{other-grep-options}}

The Linux command \texttt{grep} and regular expressions are extremely
powerful and we have only scratched the surface of what they can do.
Take a look at the manual (by typing \texttt{man\ grep}) to get an idea.
A few particularly useful options are discussed below.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
man\PY{+w}{ }grep
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{counting-matches}{%
\paragraph{Counting matches}\label{counting-matches}}

A common scenario is counting matches within files. Instead of output
each matching line, the option ``\texttt{-c}'' tells \texttt{grep} to
report the number of lines that matched. For example, the number of
genes in the autosomes in the above example can be found by simply
adding \texttt{-c} to the command.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PYZhy{}c\PY{+w}{ }\PY{l+s+s1}{\PYZdl{}\PYZsq{}\PYZca{}chr[0\PYZhy{}9]\PYZbs{}+\PYZbs{}t\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression.bed
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{case-sensitivity}{%
\paragraph{Case sensitivity}\label{case-sensitivity}}

By default, \texttt{grep} is case-sensitive. It can be useful to ignore
the distinction between upper and lower case using the option
``\texttt{-i}''. Suppose we have a file of sequences, and want to find
the sequences that contain the string ACGT. It is not unusual to come
across files that have a mix of upper and lower case nucleotides.
Consider this FASTA file:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }sequences.fasta
\end{Verbatim}
\end{tcolorbox}

    A simple search for ACGT will not return all the results:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }ACGT\PY{+w}{ }sequences.fasta
\end{Verbatim}
\end{tcolorbox}

    However, making the search case-insensitive solves the problem.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PYZhy{}i\PY{+w}{ }ACGT\PY{+w}{ }sequences.fasta
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{inverting-matches}{%
\paragraph{Inverting matches}\label{inverting-matches}}

By default, \texttt{grep} reports all lines that do match the regular
expression. Sometimes it is useful to filter a file, by reporting lines
that \textit{do not} match the regular expression. Using the option
``\texttt{-v}'' makes \texttt{grep} ``invert'' the output. For example,
we could exclude genes from autosomes in the BED file from earlier.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
grep\PY{+w}{ }\PYZhy{}v\PY{+w}{ }\PY{l+s+s1}{\PYZdl{}\PYZsq{}\PYZca{}chr[0\PYZhy{}9]\PYZbs{}+\PYZbs{}t\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression.bed
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{replacing-matches-to-regular-expressions}{%
\subsubsection{Replacing matches to regular
expressions}\label{replacing-matches-to-regular-expressions}}

Finally, we show how to replace every match to a regular expression with
something else, using the command ``\texttt{sed}''. The general form of
this is:

\begin{verbatim}
sed 's/regular expression/new string/' input_file
\end{verbatim}

This will output a new version of the input file, with each match to the
regular expression replaced with ``\texttt{new\ string}''. For example,
try:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
sed\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}s/\PYZca{}chr/chromosome/\PYZsq{}}\PY{+w}{ }gene\PYZus{}expression.bed
\end{Verbatim}
\end{tcolorbox}

    This will replace every occurence of the text ``chr'' that appears at
the start of a line in the file \texttt{gene\_expression.bed} with the
text ``chromosome''.

    \hypertarget{exercises}{%
\subsubsection{Exercises}\label{exercises}}

The following exercises all use the FASTA file \texttt{exercises.fasta}.
Before starting the exercises, open a new terminal and navigate to the
\texttt{linux/data/grep} directory, which contains
\texttt{exercises.fasta}.

Use \texttt{grep} to find the answers. Hint: some questions require you
to use \texttt{grep} twice, and possibly some other Linux commands.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Make a \texttt{grep} command that outputs just the lines with the
  sequence names.
\item
  How many sequences are in the file?
\item
  Do any sequence names have spaces in them? What are their names?
\item
  Make a \texttt{grep} command that outputs just the lines with the
  sequences, not the names.
\item
  How many sequences contain unknown bases (an ``n'' or ``N'')?
\item
  Are there any sequences that contain non-nucleotides (something other
  than A, C, G, T or N)?
\item
  How many sequences contain the 5' cut site GCWGC (where W can be an A
  or T) for the restriction enzyme AceI?
\item
  Are there any sequences that have the same name? You do not need to
  find the actual repeated names, just whether any names are repeated.
  (Hint: it may be easier to first discover how many unique names there
  are).
\end{enumerate}

    \hypertarget{file-processing-with-awk}{%
\subsection{File processing with AWK}\label{file-processing-with-awk}}

AWK is a programming language named after the initials of its three
inventors: Alfred \textbf{A}ho, Peter \textbf{W}einberger, and Brian
\textbf{K}ernighan. AWK is incredibly powerful at processing files,
particularly column-based files, which are commonplace in
Bioinformatics. For example, BED, GFF, and SAM files.

Although long programs, put into a separate file, can be written using
AWK, we will use it directly on the command line. Effectively, these are
very short AWK programs, often called ``one-liners''.

Before we start, change into the \texttt{awk} directory:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }../awk
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{extracting-columns-from-files}{%
\subsubsection{Extracting columns from
files}\label{extracting-columns-from-files}}

\texttt{awk} reads a file line-by-line, splitting each line into
columns. This makes it easy to do simple things like extract a column
from a file. We will use the following GFF file for our examples.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }genes.gff
\end{Verbatim}
\end{tcolorbox}

    The columns in the GFF file are separated by tabs and each column has
the following meaning:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Sequence name
\item
  Source - the name of the program that made the feature
\item
  Feature - the type of feature, for example gene or CDS
\item
  Start position
\item
  Stop position
\item
  Score
\item
  Strand (+ or -)
\item
  Frame (0, 1, or 2)
\item
  Optional extra information, in the form
  key1=value1;key2=value2;\ldots{}
\end{enumerate}

The score, strand, and frame can be set to `.' if it is not relevant for
that feature. The final column 9 may or may not be present and could
contain any number of key, value pairs.

We can use \texttt{awk} to just print the first column of the file.
\texttt{awk} calls the columns \texttt{\$1}, \texttt{\$2}, \ldots{} etc,
and the complete line is called \texttt{\$0}. Try

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
awk\PY{+w}{ }\PYZhy{}F\PY{l+s+s2}{\PYZdq{}\PYZbs{}t\PYZdq{}}\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZob{}print \PYZdl{}1\PYZcb{}\PYZsq{}}\PY{+w}{ }genes.gff
\end{Verbatim}
\end{tcolorbox}

    A little explanation is needed.

\begin{itemize}
\tightlist
\item
  The option \texttt{-F"\textbackslash{}t"} was needed to tell
  \texttt{awk} that the columns are separated by tabs (more on this
  later).
\item
  For each line of the file, \texttt{awk} does what is inside the curly
  brackets. In this case, we simply print the first column (\$1).
\end{itemize}

The repeated chromosome names are not nice. It is more likely to want to
know just the unique names, which can be found by piping into the Linux
command \texttt{sort}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
awk\PY{+w}{ }\PYZhy{}F\PY{l+s+s2}{\PYZdq{}\PYZbs{}t\PYZdq{}}\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZob{}print \PYZdl{}1\PYZcb{}\PYZsq{}}\PY{+w}{ }genes.gff\PY{+w}{ }\PY{p}{|}\PY{+w}{ }sort\PY{+w}{ }\PYZhy{}u
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{filtering-the-input-file}{%
\subsubsection{Filtering the input
file}\label{filtering-the-input-file}}

Similarly to \texttt{grep}, \texttt{awk} can be used to filter out lines
of a file. However, since awk is column-based, it makes it easy to
filter based on properties of any columns of interest. The filtering
criteria can be added before the braces. For example, the following
extracts just chromosome 1 from the file.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
awk\PY{+w}{ }\PYZhy{}F\PY{l+s+s2}{\PYZdq{}\PYZbs{}t\PYZdq{}}\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZdl{}1==\PYZdq{}chr1\PYZdq{} \PYZob{}print \PYZdl{}0\PYZcb{}\PYZsq{}}\PY{+w}{ }genes.gff
\end{Verbatim}
\end{tcolorbox}

    There are two important things to note from the above command:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{\$1=="chr1"} means that column 1 must be \textit{exactly} equal
  to ``chr1''. This means that ``chr10'' is not found.
\item
  The ``\texttt{\{print\ \$0\}}'' part only happens when the first
  column is equal to ``chr1'', otherwise \texttt{awk} does nothing (the
  line gets ignored).
\end{enumerate}

Awk commands are made up of two parts, a \textit{pattern}
(e.g.~\texttt{\$1=="chr1"}) and an \textit{action}
(e.g.~\texttt{print\ \$0}) which is contained in curly braces. The
\textit{pattern} defines which lines the \textit{action} is applied to.

In fact, the action (the part in curly braces) can be omitted in this
example. \texttt{awk} assumes that you want to print the whole line,
unless it is told otherwise. This gives a simple method of filtering
based on columns.

    \hypertarget{exercises}{%
\subsubsection{Exercises}\label{exercises}}

The following exercises all use the BED file \texttt{exercises.bed}.
Before starting the exercises, open a new terminal and navigate to the
\texttt{awk} directory, which contains \texttt{exercises.bed}.

Use \texttt{awk} to find the answers to the following questions about
the file \texttt{exercises.bed}. Many questions will require using pipes
(eg ``\texttt{awk\ ...\ \textbar{}\ sort\ -u}'' for question 1).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  What are the names of the contigs in the file?
\item
  How many contigs are there?
\item
  How many features are on the positive strand?
\item
  How many features are on the negative strand?
\item
  How many repeat features are there?
\end{enumerate}

    Congratulations, you have completed the Introduction to Linux tutorial!
If you have time and would like to learn more advanced concepts like
loops and bash scripts then look at \href{advanced_linux.ipynb}{Advanced
Linux}.


    % Add a bibliography block to the postdoc



\newpage





    \hypertarget{advanced-linux}{%
\section{Advanced Linux}\label{advanced-linux}}

So far, we have run single commands in a terminal. Now we will look at
ways to run more than a single command and how to automate tasks.

Before you start this section change into the \texttt{advanced\_linux}
directory:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }../advanced\PYZus{}linux
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{repeating-analysis-with-loops}{%
\subsection{Repeating analysis with
loops}\label{repeating-analysis-with-loops}}

It is common in Bioinformatics to run the same analysis on many files.
Suppose we had a script that ran one type of analysis, and wanted to
repeat the same analysis on 100 different files. It would be tedious,
and error-prone, to write the same command 100 times. Instead we can use
a loop. As an example, we will just run the Linux command \texttt{wc} on
each file in a directory.

To run \texttt{wc} on each of the files in the directory
\texttt{loop\_files/} use the following command.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for}\PY{+w}{ }filename\PY{+w}{ }\PY{k}{in}\PY{+w}{ }loop\PYZus{}files/*\PY{p}{;}\PY{+w}{ }\PY{k}{do}\PY{+w}{ }wc\PY{+w}{ }\PY{n+nv}{\PYZdl{}filename}\PY{p}{;}\PY{+w}{ }\PY{k}{done}
\end{Verbatim}
\end{tcolorbox}

    However, it is useful to be able to run multiple commands that process
some data and produce some output. These commands can be put into a file
(i.e.~a script), and run on input data. This has the advantage of saving
time and reproducibility, so that the same analysis can be run on many
input data sets.

    \hypertarget{introduction-to-bash-scripting}{%
\subsection{Introduction to BASH
scripting}\label{introduction-to-bash-scripting}}

It is traditional when learning a new language (in this case BASH), to
write a script that says ``Hello World!''. Open a terminal and make a
new directory in your home called \texttt{scripts}, by typing

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }\PYZti{}
mkdir\PY{+w}{ }\PYZti{}/scripts
\end{Verbatim}
\end{tcolorbox}

    Next open a text editor, which you will use to write the script. What
text editors are available will depend on your system. For example,
gedit in Linux. Do not try to use a word processor, such as Word! If you
don't already have a favorite, try nano by running the following
command:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
nano\PY{+w}{ }scripts/hello.sh
\end{Verbatim}
\end{tcolorbox}

    Type this into the text editor:

\begin{verbatim}
echo Hello World!
\end{verbatim}

and save this to a file called \texttt{hello.sh} in your new
\texttt{scripts} directory. This script will print
\texttt{Hello\ World!} to the screen when we run it. First, check that
the script is saved in the correct place.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
ls\PY{+w}{ }scripts/hello.sh
\end{Verbatim}
\end{tcolorbox}

    Now try to run the script. For now, we need to tell Linux that this is a
BASH script and where it is (inside the scripts directory):

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
bash\PY{+w}{ }scripts/hello.sh
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{setting-up-a-scripts-directory}{%
\subsection{Setting up a scripts
directory}\label{setting-up-a-scripts-directory}}

It would be nice if our scripts could be run from anywhere in the
filesystem, without having to tell Linux where the script is, or that it
is a BASH script. This is how built-in commands work, like \texttt{cd}
or \texttt{ls}.

To tell Linux that the script is a BASH script, edit the file and add
this line as the first line of the script:

\begin{verbatim}
#!/usr/bin/env bash
\end{verbatim}

and remember to save the script again. This special line at the start of
the file tells Linux that the file is a bash script, so that it expects
bash commands throughout the file. There is one more change to be made
to the file to tell Linux that it is a program to be run (it is
``executable''). This is done with the command \texttt{chmod}. Type this
into the terminal to make the file executable:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
chmod\PY{+w}{ }+x\PY{+w}{ }scripts/hello.sh
\end{Verbatim}
\end{tcolorbox}

    Now, the script can be run, but we must still tell Linux where the
script is in the filesystem. In this case, it is in a directory called
scripts in the current working directory, ``\texttt{./scripts}''.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
./scripts/hello.sh
\end{Verbatim}
\end{tcolorbox}

    We need to change our setup so that Linux can find the script without us
having to explicitly say where it is. Whenever a command is typed into
Linux, it has a list of directories that it searches through to look for
the command. To see the list of directories type:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{echo}\PY{+w}{ }\PY{n+nv}{\PYZdl{}PATH}
\end{Verbatim}
\end{tcolorbox}

    It returns a list of directories, which are all the places Linux will
look for a command. First, check what happens if we try to run the
script without telling Linux where it is:

\begin{verbatim}
hello.sh
bash: hello.sh: command not found
\end{verbatim}

Linux did not find it! The command to run to add the scripts directory
to \texttt{\$PATH} is:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{export}\PY{+w}{ }\PY{n+nv}{PATH}\PY{o}{=}\PY{n+nv}{\PYZdl{}PATH}:\PYZti{}/scripts/
\end{Verbatim}
\end{tcolorbox}

    If you want this change to be permanent, ie so that Linux finds your
scripts after you restart your computer or logout and login, add that
line to the end of a file called \texttt{\textasciitilde{}/.bashrc}. If
you are using a Mac, then the file should instead be
\texttt{\textasciitilde{}/.bash\_profile}. If the file does not already
exist, then create it and put that line into it.

    Now the script works, no matter where we are in the filesystem. Linux
will check the scripts directory and find the file \texttt{hello.sh}.
You can be \textit{anywhere} in your filesystem, and simply running

\begin{verbatim}
hello.sh
\end{verbatim}

will always work. Try it now.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
hello.sh
\end{Verbatim}
\end{tcolorbox}

    In general, when making a new script, you can now copy and edit an
existing script, or make a new one like this:

\begin{verbatim}
cd ~/scripts
touch my_new_script.sh
chmod +x my_new_script.sh
\end{verbatim}

and then open \texttt{my\_new\_script.sh} in a text editor.

    If you would like to learn more advanced bash scripting we have provided
some further optional material in \href{bash.ipynb}{BASH Scripting}.


    % Add a bibliography block to the postdoc



\newpage





    \hypertarget{bash-scripting}{%
\section{BASH scripting}\label{bash-scripting}}

This section is additional material and provided for anyone who would
like to learn more advanced bash scripting.

Before you start this section change into the \texttt{bash\_scripts}
directory:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{cd}\PY{+w}{ }../bash\PYZus{}scripts
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{getting-options-from-the-terminal-and-printing-a-help-message}{%
\subsection{Getting options from the terminal and printing a help
message}\label{getting-options-from-the-terminal-and-printing-a-help-message}}

Usually, we would like a script to read in options from the user, such
as the name of an input file. This would mean a script can be run like
this:

\begin{verbatim}
my_script.sh input_file
\end{verbatim}

Inside the script, the parameters provided by the user are given the
names \texttt{\$1}, \texttt{\$2}, \texttt{\$3} etc (do not confuse these
with column names used by \texttt{awk}!). Here is a simple example that
expects the user to provide a filename and a number. The script simply
prints the filename to the screen, and then the first few lines of the
file (the number of lines is determined by the number given by the
user).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }options\PYZus{}example.sh
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
options\PYZus{}example.sh\PY{+w}{ }test\PYZus{}file\PY{+w}{ }\PY{l+m}{2}
\end{Verbatim}
\end{tcolorbox}

    The options have been used by the script, but the script itself is not
very readable. It is better to use names instead of \texttt{\$1} and
\texttt{\$2}. Here is an improved version of the script that does
exactly the same as the previous script, but is more readable.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }options\PYZus{}example.2.sh
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{checking-options-from-the-user}{%
\subsection{Checking options from the
user}\label{checking-options-from-the-user}}

The previous scripts will have strange behaviour if the input is not as
expected by the script. Many things could go wrong. For example:

\begin{itemize}
\tightlist
\item
  The wrong number of options are given by the user
\item
  The input file does not exist.
\end{itemize}

Try running the script with different options and see what happens.

A convention with scripts is that it should output a help message if it
is not run correctly. This shows anyone how the script should be run
(including you!) without having to look at the code inside the script.

A basic check for this script would be to verify that two options were
supplied, and if not then print a help message. The code looks like
this:

\begin{verbatim}
if [ $# -ne 2 ]
then
        echo "usage: options_example.3.sh filename number_of_lines"
        echo
        echo "Prints the filename, and the given first number of lines of the file"
        exit
fi
\end{verbatim}

You can copy this code into the start of any of your scripts, and easily
modify it to work for that script. A little explanation:

\begin{itemize}
\tightlist
\item
  A special variable \texttt{\$\#} has been used, which is the number of
  options that were given by the user.
\item
  The whole block of code has the form
  ``\texttt{if\ {[}\ \$\#\ -ne\ 2\ {]}\ then\ ....\ fi}''. This only
  runs the code between the \texttt{then} and \texttt{fi}, if
  \texttt{\$\#} (the number of options) is not 2.
\item
  The line \texttt{exit} simply makes the script end, so that no more
  code is run.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
options\PYZus{}example.3.sh
\end{Verbatim}
\end{tcolorbox}

    Another check is that the input file really does exist. If it does not
exist, then there is no point in trying to run any more code. This can
be checked with another \texttt{if\ ...\ then\ ...\ fi} block of code:

\begin{verbatim}
if [ ! -f $filename ]

then
    echo "File '$filename' not found! Cannot continue"
    exit
fi
\end{verbatim}

Putting this all together, the script now looks like this:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
cat\PY{+w}{ }options\PYZus{}example.3.sh
\end{Verbatim}
\end{tcolorbox}

    Two new features have also been introduced in this file:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  The second line is ``\texttt{set\ -eu}''. Without this line, if any
  line produces an error, the script will carry on regardless to the end
  of the script. Using the \texttt{-e} option, an error anywhere in the
  file will result in the script stopping at the line that produced the
  error, instead of continuing. In general, it is best that the script
  stops at any error. The \texttt{-u} creates an error if you try to use
  a variable which doesn't exist. This helps to stop typos doing bad
  things to your analysis.
\item
  There are several lines starting with a hash \texttt{\#}. These lines
  are ``comment lines'' that are not run. They are used to document the
  code, containing explanations of what is happening. It is good
  practice to comment your scripts!
\end{enumerate}

The above script provides a template for writing your own scripts. The
general method is:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Tell Linux that this is a BASH script, and to stop at the first error.
\item
  Check if the user ran the script correctly. If not, output a message
  telling the user how to run the script.
\item
  Check the input looks OK (in this case, that the input file exists).
\item
  Process the input.
\end{enumerate}

\hypertarget{using-variables-to-store-output-from-commands}{%
\subsection{Using variables to store output from
commands}\label{using-variables-to-store-output-from-commands}}

It can be useful to run a command and put the results into a variable.
Recall that we stored the input from the user in sensibly named
variables:

\begin{verbatim}
filename=$1
\end{verbatim}

The part after the equals sign could actually be any command that
returns some output. For example, running this in Linux

\begin{verbatim}
wc -l filename | awk '{print $1}'
\end{verbatim}

returns the number of lines. In case you are wondering why the command
includes
\texttt{\textbar{}\ awk\ \textquotesingle{}\{print\ \$1\}\textquotesingle{}},
check what happens with and without the pipe to \texttt{awk}:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
wc\PY{+w}{ }\PYZhy{}l\PY{+w}{ }options\PYZus{}example.3.sh
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
wc\PY{+w}{ }\PYZhy{}l\PY{+w}{ }options\PYZus{}example.3.sh\PY{+w}{ }\PY{p}{|}\PY{+w}{ }awk\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZob{}print \PYZdl{}1\PYZcb{}\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

    With a small change, this can be stored in a variable and then used
later.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nv}{filename}\PY{o}{=}options\PYZus{}example.3.sh
\PY{n+nv}{line\PYZus{}count}\PY{o}{=}\PY{k}{\PYZdl{}(}wc\PY{+w}{ }\PYZhy{}l\PY{+w}{ }\PY{n+nv}{\PYZdl{}filename}\PY{+w}{ }\PY{p}{|}\PY{+w}{ }awk\PY{+w}{ }\PY{l+s+s1}{\PYZsq{}\PYZob{}print \PYZdl{}1\PYZcb{}\PYZsq{}}\PY{k}{)}
\PY{n+nb}{echo}\PY{+w}{ }There\PY{+w}{ }are\PY{+w}{ }\PY{n+nv}{\PYZdl{}line\PYZus{}count}\PY{+w}{ }lines\PY{+w}{ }\PY{k}{in}\PY{+w}{ }the\PY{+w}{ }file\PY{+w}{ }\PY{n+nv}{\PYZdl{}filename}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{exercises}{%
\subsection{Exercises}\label{exercises}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a script that gets a filename from the user. If the file exists,
  it prints a nice human-readable message telling the user how many
  lines are in the file.
\item
  Use a loop to run the script from Exercise 1 on the files in the
  directory \texttt{loop\_files/}.
\item
  Write a script that takes a GFF filename as input. Make the script
  produce a summary of various properties of the file. There is an
  example input file provided called
  \texttt{bash\_scripts/exercise\_3.gff}. Use your imagination! You
  could have a look back at the \texttt{awk} section of the course for
  inspiration. Here are some ideas you may wish to try:
\end{enumerate}

\begin{itemize}
\tightlist
\item
  Does the file exist?
\item
  How many records (ie lines) are in the file?
\item
  How many genes are in the file?
\item
  Is the file badly formatted in any way (eg wrong number of columns, do
  the coordinates look like numbers)?
\end{itemize}


    % Add a bibliography block to the postdoc



\newpage





    \hypertarget{linux-quick-reference-guide}{%
\section{Linux Quick Reference
Guide}\label{linux-quick-reference-guide}}

\hypertarget{looking-at-files-and-moving-them-around}{%
\subsection{Looking at files and moving them
around}\label{looking-at-files-and-moving-them-around}}

\begin{verbatim}
pwd # Tell me which directory I'm in
ls # What else is in this directory
ls .. # What is in the directory above me
ls foo/bar/ # What is inside the bar directory which is inside the foo/ directory
ls -lah foo/ # Give the the details (-l) of all files and folders (-a) using human
             # readable file sizes (-h)
cd ../.. # Move up two directories
cd ../foo/bar # Move up one directory and down into the foo/bar/ subdirectories
cp -r foo/ baz/ # Copy the foo/ directory into the baz/ directory
mv baz/foo .. # Move the foo directory into the parent directory
rm -r ../foo # remove the directory called foo/ from the parent directory
find foo/ -name "*.gff" # find all the files with a gff extension in the directory foo/
\end{verbatim}

\hypertarget{looking-in-files}{%
\subsection{Looking in files}\label{looking-in-files}}

\begin{verbatim}
less bar.bed # scroll through bar.bed
grep chrom bar.bed | less -S # Only look at lines in bar.bed which have 'chrom' and
                             # don't wrap lines (-S)
head -20 bar.bed # show me the first 20 lines of bar.bed
tail -20 bar.bed # show me the last 20 lines
cat bar.bed # show me all of the lines (bad for big files)
wc -l bar.bed # how many lines are there
sort -k 2 -n bar.bed # sort by the second column in numerical order
\end{verbatim}

\hypertarget{grep}{%
\subsection{Grep}\label{grep}}

\begin{verbatim}
grep foo bar.bed # show me the lines in bar.bed with 'foo' in them
grep foo baz/* # show me all examples of foo in the files immediately within baz/
grep -r foo baz/ # show me all examples of foo in baz/ and every subdirectory within it
grep '^foo' bar.bed # show me all of the lines begining with foo
grep 'foo$' bar.bed # show me all of the lines ending in foo
grep -i '^[acgt]$' bar.bed # show me all of the lines which only have the characters
                           # a,c,g and t (ignoring their case)
grep -v foo bar.bed # don't show me any files with foo in them
\end{verbatim}

\hypertarget{awk}{%
\subsection{Awk}\label{awk}}

\begin{verbatim}
awk '{print $1}' bar.bed # just the first column
awk '$4 ~ /^foo/' bar.bed # just rows where the 4th column starts with foo
awk '$4 == "foo" {print $1}' bar.bed # the first column of rows where the 4th column is foo
awk -F"\t" '{print $NF}' bar.bed # ignore spaces and print the last column
awk -F"\t" '{print $(NF-1)}' bar.bed # print the penultimate column
\end{verbatim}

\hypertarget{piping-redirection-and-more-advanced-queries}{%
\subsection{Piping, redirection and more advanced
queries}\label{piping-redirection-and-more-advanced-queries}}

\begin{verbatim}
grep -hv '^#' bar/*.gff | sort
#  grep => -h: don't print file names
#          -v: don't give me matching files
#          '^#': get rid of the header rows
#          'bar/*.gff': only look in the gff files in bar/
#  sort => sort results returned from grep
\end{verbatim}

\hypertarget{a-script}{%
\subsection{A script}\label{a-script}}

\begin{verbatim}
#!/usr/bin/env bash

set -e # stop running the script if there are errors
set -u # stop running the script if it uses an unknown variable
set -x # print every line before you run it (useful for debugging but annoying)

if [ $# -ne 2 ]
then
  echo "You must provide two files"
  exit 1 # exit the programme (and number > 0 reports that this is a failure)
fi

file_one=$1
file_two=$2

if [ ! -f $file_one ]
then
  echo "The first file couldn't be found"
  exit 2
fi

if [ ! -f $file_two ]
then
  echo "The second file couldn't be found"
  exit 2
fi

# Get the lines which aren't headers,
# take the first column and return the unique values
number_of_contigs_in_one=$(awk '$1 !~ /^#/ {print $1}' $file_one | sort -u | wc -l)
number_of_contigs_in_two=$(awk '/^[^#]/ {print $1}' $file_two | sort -u | wc -l)

if [ $number_of_contigs_in_one -gt $number_of_contigs_in_two ]
then
  echo "The first file had more unique contigs than the second"
  exit
elif [ $number_of_contigs_in_one -lt $number_of_contigs_in_two ]
then
  echo "The second file had more unique contigs"
  exit
else
  echo "The two files had the same number of contigs"
  exit
fi
\end{verbatim}

\hypertarget{pro-tips}{%
\subsection{Pro tips}\label{pro-tips}}

\begin{itemize}
\tightlist
\item
  Use tab completion - it will save you time!
\item
  Always have a quick look at files with \texttt{less} or \texttt{head}
  to double check their format
\item
  Watch out for data in headers and that you don't accidentally grep
  some if you don't want them
\item
  Watch out for spaces, especially if you're using awk; if in doubt, use
  \texttt{-F"\textbackslash{}t"}
\item
  Regular expressions are wierd, build them up slowly bit by bit
\item
  If you did something smart but can't remember what it was, try typing
  \texttt{history} and it might have a record
\item
  \texttt{man\ the\_name\_of\_a\_command} often gives you help
\item
  Google is normally better at giving examples (prioritise
  stackoverflow.com results, they're normally good)
\end{itemize}

\hypertarget{which-tool-should-i-use}{%
\subsection{Which tool should I use?}\label{which-tool-should-i-use}}

You should probable use grep if:

\begin{itemize}
\tightlist
\item
  you're looking for files which contain some specific text
  (e.g.~\texttt{grep\ -r\ foo\ bar/}: look in all the files in
  \texttt{bar/} for any with the word `foo')
\end{itemize}

You should probably use awk if:

\begin{itemize}
\tightlist
\item
  your data has columns
\item
  you need to do simple maths
\end{itemize}

You should use find if:

\begin{itemize}
\tightlist
\item
  you know something about a file (like it's name or creation date) but
  not where it is
\item
  you want a list of all the files in a subdirectory and its
  subdirectories etc.
\end{itemize}

You should write a script if:

\begin{itemize}
\tightlist
\item
  your code doesn't fit on one line
\item
  it's doing something you might want to do again in 3 months
\item
  you want someone else to be able to do it without asking loads of
  questions
\item
  you're doing something sensitive (e.g.~deleting loads of files)
\item
  you're doing something lots of times
\end{itemize}

You should probably use less or head:

\begin{itemize}
\tightlist
\item
  always, you should always use less or head to check intermediary steps
  in your analysis
\end{itemize}


    % Add a bibliography block to the postdoc



\end{document}
